## 2024-11-20 학습내용
#### 제돌 스토리 서버 백엔드 & 프론트엔드  **커스터마이즈** 하기
- 패치(patch)와 커스터마이즈(customize)
    - 패치(patch)
        - 기존 코드에 버그 수정이나 기능을 추가할 때
        - 보안 업데이트를 적용할 때
        - 임시적인 수정사항을 적용할 때
    - 커스터마이즈(customize)
        - 사용자의 필요에 맞게 기능을 변경할 때
        - 인터페이스나 설정을 개인화할 때
        - 기본 기능을 확장하거나 수정할 때
        - 장기적인 사용자 맞춤 변경을 할 때

## 1. 제돌 스토리 서버 실행 해보기 
### .env 파일(환경변수)을 만든다.
- .env 파일을 연다
- OPENAI_API_KEY="사용하는 오픈AI API 키를 입력"

### 제돌 스토리의 서버 백엔드 시작 모듈인 main.py 파일을 연다.
- 터미널을 연다. ctrl + `
- 실행할 파이썬을 선택 또는 확인한다.(기본적으로 설치된 파이썬을 사용함,여러버전이 설치된 경우 화면하단 터미널 탭에서 확인 또는 변경 가능)
- 설치할 라이브러리 파일을 생성한다.
```
pip freeze > requirements.txt
```
- 라이브러리를 설치한다.
```
pip install -r requirements.txt
```
### main.py 파일을 실행한다.
#### 실행 방법 3가지 
1. 터미널에서 실행
```
python main.py
```
2. 화면 상단의 ▶ 버튼을 눌러 실행 -> 단축기 : ctrl + f5
3. F5키를 눌러 실행 ( F5키 누르면 디버깅 모드로 실행되는데 여러기지 선택하라고뜨는데 첫번째 옵션을 선택 하면 된다.), 개발단개에서는 가장 많이 사용
- 디버깅 모드 사용법
    - F5          : 디버깅 시작/계속
    - F9          : 중단점 설정/해제
    - F10         : 한 줄씩 실행(Step Over)
    - F11         : 함수 내부로 들어가기(Step Into)
    - Shift + F11 : 함수 밖으로 나가기(Step Out)

### main.py 정상적으로 실행되는지 확인한다. 다음과 같은 내용이 나오면 정상적으로 실행된 것이다.
```
INFO:     Will watch for changes in these directories: ['C:\\jshs-2024-11-20'] 
INFO:     Uvicorn running on http://PC-IP주소:8080 (Press CTRL+C to quit)
INFO:     Started reloader process [38084] using StatReload
INFO:     Started server process [27836]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```
### http://PC-IP주소:8080 접속해서 정상적으로 실행되는지 확인한다.

#### 실행 중지
- 터미널에서 ctrl + c 를 누른다.

### 실행이 완료되고 확인되면 실행 중지하고 다음 학습 단계로 ...

## 2. 제돌 스토리의 백엔드 살펴보기
### 파일 구조
```
JSHS-2024-11-20/                 # 프로젝트 루트 디렉토리
├── .env                         # 환경변수 파일 (OpenAI API 키 등을 안전하게 관리)
├── requirements.txt             # 프로젝트에 필요한 파이썬 패키지 의존성 목록
├── main.py                      # FastAPI 서버 실행 및 라우팅 설정을 담당하는 메인 파일
└── templates/                   # 프론트엔드 관련 파일들을 포함하는 디렉토리
    ├── index.html              # 메인 페이지의 HTML 구조를 정의하는 템플릿 파일
    ├── css/                    # 스타일 관련 파일들을 포함하는 디렉토리
    │   └── main.css           # 웹페이지의 디자인과 레이아웃을 정의하는 스타일시트
    ├── js/                     # 클라이언트 측 로직을 담당하는 디렉토리
    │   └── main.js            # 사용자 인터랙션과 API 통신을 처리하는 자바스크립트 파일
    └── images/                 # 웹사이트에서 사용되는 이미지 리소스 디렉토리
        └── favicon.ico         # 브라우저 탭에 표시되는 웹사이트 아이콘
```

각 파일과 디렉토리는 다음과 같은 역할을 합니다:
- `.env`: 보안이 필요한 설정값들을 환경변수로 관리
- `main.py`: 서버의 진입점으로, API 엔드포인트와 엔드포인트 로직 구현
- `templates/`: 사이트 View에 해당하는 프론트엔드 파일들을 관리

### 사용된 라이브러리
- from fastapi import FastAPI        # FastAPI 웹 프레임워크
- from fastapi.responses import HTMLResponse, FileResponse  # 웹 응답 처리
- from openai import OpenAI          # OpenAI API 사용
- from dotenv import load_dotenv     # 환경변수 로드
- import uvicorn                     # ASGI 서버
- import os                          # 운영체제 관련 기능 사용
- import socket                      # 네트워크 기능

### 시작점 변수 및 인스턴스 생성
- .env 파일에서 환경변수 로드 (API 키 등)
```
load_dotenv()
```
- OpenAI API 클라이언트 초기화 (환경변수에서 'OPENAI_API_KEY'에 저장된 API 키 가져옴)
```
client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
```
- FastAPI 애플리케이션 객체 생성
```
app = FastAPI()
```
- 대화 기록을 저장할 리스트 변수 생성
```
messages_list = []
```
### 서버 엔드포인트(라우팅) 설정
#### 루트 경로("/") 처리 - 메인 페이지 반환
```
@app.get("/")
async def root_page():
    return FileResponse("templates/index.html")
```
#### 정적 파일 처리 (HTML, CSS, JS 등)
```
@app.get("/{path:path}", response_class=HTMLResponse)
async def serve_page(path: str):
    
    # templates 폴더에서 요청된 파일 찾기
    file_path = os.path.join("templates", path)
    if os.path.exists(file_path):
        return FileResponse(file_path)
    return "404 - 페이지를 찾을 수 없습니다."
```
#### 채팅 API 엔드포인트
``` 
@app.post("/chat")
async def chat_endpoint(message: dict):
    """채팅 메시지를 처리하고 AI 응답을 반환하는 엔드포인트"""
    try:
        # 시스템 프롬프트(학교 안내파일) 설정 

        if not messages_list : # messages_list가 비어있는지 확인
            # messages_list에 이전 대화 내용이 없는 경우는 처음 시작할 때
            # jshs-story.txt 파일에서 시스템 설정 읽기
            with open('data/jshs-story.txt', 'r', encoding='utf-8') as f: # encoding='utf-8' 한글 인코딩
                messages_list.append({
                    "role": "system",
                    "content": f.read()
                })

        # 사용자 메시지를 대화 기록에 추가
        messages_list.append({
            "role": "user", 
            "content": message["message"]
        })
        
        # OpenAI API를 통해 AI 응답 생성
        response = client.chat.completions.create(
            model="gpt-4o-mini",  # 사용할 AI 모델
            messages=messages_list,
            temperature=0.7       # 값이 낮을수록(0에 가까울수록) 더 일관되고 예측 가능한 응답을 생성합니다. 0.7은 적당한 창의성과 일관성의 균형을 제공하는 중간 값입니다.
            # temperature=0.7 # 응답의 창의성 조절 (0: 보수적, 1: 창의적)
            # max_tokens=1000 # 응답 최대 길이 
            # top_p=0.9 # 응답 다양성 조절
            # frequency_penalty=0.0 # 단어 반복 억제 (-2.0 ~ 2.0)
            # n=1 # 생성할 응답 수
            # stream=False # 스트리밍 응답 여부

            # tokens는 AI가 생성하는 텍스트의 길이를 제한하는 단위입니다.
            # 1토큰은 대략 영어 4글자 또는 한글 1-2글자 정도입니다.
            # max_tokens=1000 # 응답 최대 길이를 1000토큰(약 영어 4000자, 한글 1000-2000자)으로 제한
            # 예시: "안녕하세요" = 2-3토큰, "Hello" = 1토큰
            # GPT-4 모델의 경우 입력+출력 합쳐서 최대 8000토큰까지 처리 가능

        )
        
        # AI 응답을 대화 기록에 추가
        assistant_message = response.choices[0].message.content
        messages_list.append({
            "role": "assistant", 
            "content": assistant_message
        })
        
        return {"response": assistant_message}
    
    except Exception as e:
        return {"error": str(e)}
```
### 서버 메인 실행 부분
``` 
if __name__ == "__main__":
    # 현재 컴퓨터의 호스트명과 IP 주소 가져오기
    hostname = socket.gethostname()
    HOST = socket.gethostbyname(hostname)
    PORT = 8080
    
    # 서버 시작 메시지 출력
    print(f"****서버 시작: http://{HOST}:{8080}****")
    # uvicorn 서버 실행 (자동 재시작 활성화)
    uvicorn.run("main:app", host=HOST, port=8080, reload=True)
```

## 3. 제돌 스토리의 프론트엔드 살펴보기
### index.html 파일
- html 기본 tag
- `<!DOCTYPE html>`: HTML5 문서임을 선언
- `<html lang="ko">`: HTML 문서의 시작, 한국어 설정
- `<head>`: 문서의 메타데이터 영역
  - `<meta>`: 문서의 각종 메타 정보 설정
    - charset: 문자 인코딩 설정
    - viewport: 모바일 반응형 설정
    - description: 페이지 설명
    - keywords: 검색 키워드
    - author: 작성자 정보
  - `<title>`: 브라우저 탭에 표시될 제목
  - `<link>`: 외부 리소스(CSS) 연결
- `<body>`: 실제 콘텐츠가 들어가는 영역
  - `<div>`: 콘텐츠를 묶는 컨테이너 요소
  - `<span>`: inline 콘텐츠를 묶는 요소
  - `<p>`: 문단 요소
  - `<br>`: 줄바꿈 요소
  - `<img>`: 이미지 요소
  - `<textarea>`: 여러 줄 텍스트 입력 영역
  - `<button>`: 클릭 가능한 버튼 요소
  - `<script>`: 자바스크립트 코드 삽입
  #### `<link>`는 head 태그 안에 있어야 한다. `<script>`는 body 태그 안에 있어야 한다.
```

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="제주과학고등학교 학생들의 이야기를 들려주는 AI 챗봇입니다.">
    <meta name="keywords" content="제주과학고등학교, 제주과학고, 제돌이, AI 챗봇, 학교생활">
    <meta name="author" content="제주과학고등학교">
    <title>제돌 스토리</title>
    <!-- Bootstrap: 반응형 UI 컴포넌트 및 스타일링을 위한 css 프레임워크 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Highlight.js: 코드 구문 강조를 위한 css 라이브러리 -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" rel="stylesheet">
    <!-- Font Awesome: 아이콘을 위한 라이브러리 -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <!-- 사용자가 만든 css 파일 -->
    <link href="/css/main.css" rel="stylesheet">
    
</head>
<body>
    
        <!-- 전체 컨테이너: 최대 너비 설정, 위쪽 여백 4단위, 글자 크기 5단위 -->
        <div class="container-xl mt-4 fs-5">
            <!-- 카드 컴포넌트: 약간의 그림자와 회색 테두리 -->
            <div class="card shadow-sm border-secondary ">
                <!-- 카드 헤더: 파란색 배경, 흰색 글자, 위아래 패딩 3단위 -->
                <div class="card-header bg-primary text-light py-3">
                    <!-- 카드 제목: 아래쪽 여백 없음, 글자 크기 4단위 -->
                    <div class="card-title mb-0 fs-4">제돌 스토리</div>
                    <!-- 카드 부제목: 아래쪽 여백 없음, 글자 크기 6단위 -->
                    <div class="card-subtitle mb-0 fs-6">제주과학고등학교 학생들의 이야기를 들려주는 AI 챗봇입니다.</div>
                </div>
                <!-- 카드 본문: 어두운 배경, 밝은 글자색 -->
                <div class="card-body bg-dark text-light">
                    <!-- 채팅 메시지가 표시될 영역: 투명 배경 -->
                    <div id="chat-messages" class="bg-transparent"></div>
                    <!-- 입력 영역: 위쪽 여백 3단위 -->
                    <div class="mt-3">
                        <!-- 입력 그룹: 텍스트 입력과 버튼을 묶음 -->
                        <div class="input-group">
                            <!-- 메시지 입력 텍스트영역: 글자크기 5단위, 테두리 없음, 밝은 배경, 어두운 글자 -->
                            <textarea id="message-input" class="fs-5 form-control border-0 bg-light text-dark border-secondary shadow-none"
                             placeholder="메시지를 입력하세요" rows="1" ></textarea>
                            
                            <!-- 전송 버튼: 회색 배경, 좌우 패딩 3단위 -->
                            <button class="btn btn-secondary px-3" type="button" id="send-button">
                                전송
                            </button>
                        </div>
                        <!-- 에러 메시지 영역: 빨간색 경고창, 위쪽 여백 2단위, 기본적으로 숨김 -->
                        <div id="error-message" class="alert alert-danger mt-2 d-none"></div>
                    </div>
                </div>
            </div>
        </div>
    

    
    <!-- jQuery: DOM 조작 및 AJAX 요청을 위한 JavaScript 라이브러리 -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <!-- Bootstrap: 반응형 UI 컴포넌트 및 스타일링을 위한 프레임워크 -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Marked: 마크다운을 HTML로 변환하기 위한 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Highlight.js: 코드 구문 강조를 위한 라이브러리 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- DOMPurify: XSS 공격 방지를 위한 HTML 새니타이저 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <!-- 사용자가 만든 메인 JavaScript 파일 -->
    <script src="/js/main.js"></script>
</body>
</html>

```

- 부트스크랩 프레임워크에서 많이 기본으로 사용하는 클래스
#### 부트스트랩 기본 클래스
1. 레이아웃 관련
- container: 반응형 고정 너비 컨테이너
- container-fluid: 전체 너비 컨테이너
- row: 행 생성
- col-{size}: 열 생성 (size: 1-12)

2. 여백과 패딩
- m-{size}: 마진 (size: 0-5)
- mt-{size}: 상단 마진
- mb-{size}: 하단 마진
- ms-{size}: 좌측 마진
- me-{size}: 우측 마진
- p-{size}: 패딩
- pt, pb, ps, pe: 각 방향 패딩

3. 색상
- text-{color}: 텍스트 색상
  - primary: 파란색 (#0d6efd)
  - secondary: 회색 (#6c757d)
  - success: 녹색 (#198754)
  - danger: 빨간색 (#dc3545)
  - warning: 노란색 (#ffc107)
  - info: 하늘색 (#0dcaf0)
  - light: 밝은 회색 (#f8f9fa)
  - dark: 어두운 회색 (#212529)

4. 배경색
- bg-{color}: 배경색 (위와 동일한 color 옵션)

5. 테두리
- border: 테두리 추가
- border-{color}: 테두리 색상
- border-0: 테두리 제거
- border-top, border-bottom, border-left, border-right: 각 방향 테두리
- rounded: 둥근 모서리
- shadow-{size}: 그림자 효과 (sm, md, lg)

6. 텍스트 관련
- fs-{size}: 글자 크기 (1-6)
- fw-bold: 굵은 글씨
- text-center: 가운데 정렬
- text-start: 왼쪽 정렬
- text-end: 오른쪽 정렬

7. 디스플레이
- d-none: 숨김
- d-block: 블록 요소로 표시
- d-flex: 플렉스 박스로 표시

8. 간격
- gap-{size}: 그리드 아이템 간 간격

9. 버튼
- btn: 기본 버튼
- btn-{color}: 버튼 색상
- btn-outline-{color}: 테두리만 있는 버튼

10. 폼
- form-control: 입력 필드
- form-select: 선택 메뉴
- form-check: 체크박스/라디오
- input-group: 입력 그룹



### main.css 파일 살펴보기
``` 
/* body 태그 스타일 */
body {
    position: relative;                                 /* 상대 위치 지정 */
    font-family:'SCoreDream','NanumBarunGothic';      /* 기본 글꼴 설정 */
    font-size: 1.2em !important;                       /* 글자 크기를 1.2배로 강제 지정 */
    background-color: #00292f;                         /* 짙은 청록색 배경 */
}

/* 채팅 컨테이너 스타일 */
.chat-container {
    max-width: 800px;                                  /* 최대 너비 800px로 제한 */
    margin: 0 auto;                                    /* 가운데 정렬 */
}

/* 채팅 메시지 영역 스타일 */
#chat-messages {
    height: 80vh;                                      /* 화면 높이의 80% */
    overflow-y: auto;                                  /* 세로 스크롤바 자동 표시 */
    padding: 15px;                                     /* 안쪽 여백 */
}

/* 개별 메시지 스타일 */
.message {
    margin-bottom: 10px;                              /* 아래쪽 여백 */
    padding: 10px;                                    /* 안쪽 여백 */
    word-wrap: break-word;                            /* 긴 단어 자동 줄바꿈 */
}

/* 마크다운으로 작성된 메시지 내부 요소들의 스타일 */
.message img {
    max-width: 100%;                                  /* 이미지 최대 너비 */
    height: auto;                                     /* 높이 자동 조정 */
}

/* 코드 블록 스타일 */
.message pre {
    padding: 1rem;                                    /* 안쪽 여백 */
    border-radius: 4px;                               /* 모서리 둥글게 */
    overflow-x: auto;                                 /* 가로 스크롤바 자동 표시 */
}

/* 인라인 코드 스타일 */
.message code {
    padding: 0.2em 0.4em;                            /* 안쪽 여백 */
    border-radius: 3px;                              /* 모서리 둥글게 */
    font-family: monospace;                          /* 고정폭 글꼴 */
}

/* 코드 블록 내부의 코드 스타일 */
.message pre code {
    padding: 0;                                      /* 안쪽 여백 제거 */
    background-color: transparent;                    /* 배경색 투명하게 */
}

/* 테이블 스타일 */
.message table {
    border-collapse: collapse;                       /* 테두리 겹침 제거 */
    margin: 1em 0;                                  /* 위아래 여백 */
    width: 100%;                                    /* 전체 너비 사용 */
}

/* 테이블 셀 스타일 */
.message th,
.message td {
    border: 1px solid #dee2e6;                      /* 테두리 */
    padding: 0.5em;                                 /* 안쪽 여백 */
}

/* 인용구 스타일 */
.message blockquote {
    border-left: 4px solid #dee2e6;                 /* 왼쪽 테두리 */
    margin: 0;                                      /* 바깥 여백 제거 */
    padding-left: 1em;                              /* 왼쪽 안쪽 여백 */
    color: #6c757d;                                 /* 회색 글자색 */
}

/* 메시지 입력창 스타일 */
#message-input {
    resize: none;                                   /* 크기 조절 비활성화 */
    max-height: 200px;                              /* 최대 높이 제한 */
}
```
### main.js 파일 살펴보기
```
/* templates/js/main.js */
$(document).ready(function() {
    /* 
     * jQuery의 document.ready() 함수
     * - DOM(html, css, js)가 완전히 로드된 후 실행되는 코드 블록
     * - 페이지의 모든 HTML 요소가 준비된 후에 jQuery 코드를 실행하여 안전성 보장
     * - 사용자 인터페이스 초기화 및 이벤트 핸들러 설정을 담당
     */
    let isProcessing = false;
    const messageInput = $('#message-input')
    const sendButton = $('#send-button');
   
    const chatMessages = $('#chat-messages');
    // 사용자와 어시스턴트 아이콘 정의
    const userIcon = '<i class="fa-solid fa-user me-2 text-primary"></i>';
    const assistantIcon = '<i class="fa-regular fa-user me-2 text-success"></i>';

    // CDN: cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js
    marked.setOptions({
        highlight: function(code, lang) {
            // 코드 하이라이팅을 처리하는 함수
            // 마크다운을 HTML로 변환하고 코드 하이라이팅을 적용하는 옵션 설정
            // 하이라이팅: 코드 블록에 구문 강조(syntax highlighting)를 적용하여 가독성을 높이는 기능
            // hljs는 highlight.js의 인스턴스입니다.
            // hljs.getLanguage() 메소드는 highlight.js의 언어 감지 기능을 제공합니다.
            // hljs.highlightAuto() 메소드는 코드 내용을 자동으로 언어로 인식하여 하이라이팅을 적용합니다.

            // 언어가 지정되어 있고 highlight.js가 해당 언어를 지원하는 경우
            if (lang && hljs.getLanguage(lang)) {
                // 지정된 언어로 코드 하이라이팅 적용
                return hljs.highlight(code, { language: lang }).value;
            }
            // 언어가 지정되지 않은 경우 자동으로 언어 감지하여 하이라이팅 적용
            return hljs.highlightAuto(code).value;
        },
        breaks: true, // 줄바꿈을 <br> 태그로 변환
        gfm: true // GitHub Flavored Markdown 활성화
    });

    function adjustTextareaHeight() {
        // 텍스트 입력창의 높이를 내용에 맞게 자동으로 조절하는 함수
        messageInput.height('auto').height(messageInput[0].scrollHeight);
    }

    // CDN: cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js
    function appendMessage(role, content) {
        // 채팅 메시지를 화면에 추가하는 함수
        // role: 메시지 작성자(user/assistant)
        // content: 메시지 내용
        // DOMPurify는 HTML 콘텐츠를 안전하게 정화(sanitize)하는 라이브러리입니다.
        // XSS(Cross-Site Scripting) 공격을 방지하기 위해 사용됩니다.
        // XSS: 악의적인 스크립트를 웹페이지에 삽입하여 사용자의 정보를 탈취하는 공격
        
        const htmlContent = role === 'assistant' ? 
            DOMPurify.sanitize(marked.parse(content)) : 
            DOMPurify.sanitize(content);

        // role에 따라 적절한 아이콘 선택
        const icon = role === 'assistant' ? assistantIcon : userIcon;

        const messageDiv = $('<div>')
            .addClass(`message ${role}-message`)
            .html(` 
                <div class="d-flex">
                    <div class="me-2">${icon}</div>
                    <div>
                        ${htmlContent}
                    </div>
                </div>
            `);

        chatMessages.append(messageDiv);
        
        messageDiv.find('pre code').each(function(i, block) {
            hljs.highlightBlock(block);
        });

        chatMessages.scrollTop(chatMessages[0].scrollHeight);
    }

    function sendMessage(message, showUserMessage = true, isInitialMessage = false) {
        // 메시지를 서버로 전송하고 응답을 처리하는 함수
        // message: 전송할 메시지 내용
        // showUserMessage: 사용자 메시지를 화면에 표시할지 여부
        // isInitialMessage: 초기 접속 메시지인지 여부
        
        if (isProcessing) return;
        
        const messageText = message || messageInput.val().trim();
        if (!messageText) return;

        isProcessing = true;
        sendButton.prop('disabled', true);
        
        if (showUserMessage) {
            appendMessage('user', messageText);
        }
        
        if (!message) {
            messageInput.val('').trigger('input');
        }

        const loading = $('<div>')
            .addClass('my-2')
            .html(`${assistantIcon}<div class="spinner-border spinner-border-sm text-primary"></div> ${
                isInitialMessage ? 'ChatGPT에 접속 중...' : '응답 생성 중...'
            }`);

        chatMessages.append(loading);
        
        $.ajax({
            url: '/chat',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ message: messageText }),
            success: function(data) {
                loading.remove();
                if (data.error) {
                    appendMessage('assistant', `오류가 발생했습니다: ${data.error}`);
                    return;
                }
                appendMessage('assistant', data.response);
            },
            error: function(xhr, status, error) {
                console.error('Error:', error);
                loading.remove();
                appendMessage('assistant', `오류가 발생했습니다: ${error}`);
            },
            complete: function() {
                isProcessing = false;
                sendButton.prop('disabled', false);
                messageInput.focus();
            }
        });
    }

    // 이벤트 핸들러 등록 - 텍스트 입력창 높이 조절 및 Enter 키 입력 처리
    messageInput
        .on('input', adjustTextareaHeight)
        .on('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

    // 전송 버튼 클릭 이벤트 처리
    sendButton.on('click', function() {
        sendMessage();
    });
    
    // 페이지 로드 시 접속 확인을 위한 초기 인사말 목록 생성
    const greetings = [
        "안녕하세요! 반가워요!",
        "안녕하세요, 오늘도 좋은 하루 보내세요!",
        "반갑습니다! 잘 지내고 있나요?",
        "안녕하세요! 대화를 시작해볼까요?",
        "반가워요! ",
        "안녕!",
        "안녕, 기분이 어떤가요?"
    ];
    // 랜덤 인덱스 생성
    // greetings.length: 인사말 목록의 길이
    const randomIndex = Math.floor(Math.random() * greetings.length);
    // greetings 목록에서 랜덤 인덱스로 랜덤 인사말 선택
    const randomGreeting = greetings[randomIndex];
    // 선택한 랜덤 인사말로 sendMessage 함수를 통해 초기 메시지 전송
    // sendMessage(randomGreeting, false, true);
});
```

## 4. 프론트엔드 커스터마이징 실습

#### 크롬 개발자 도구 사용하기
##### 크롬 개발자 도구 열기 - F12 키
##### 주요 패널 설명
- Elements : HTML/CSS 구조 확인 및 수정
- Console : 자바스크립트 실행 및 디버깅
- Sources : 소스코드 확인 및 디버깅
- Network : 네트워크 요청/응답 모니터링
- Application : 웹 스토리지, 캐시 등 관리

##### Elements 패널 활용
- HTML 구조 탐색
- CSS 스타일 실시간 수정
- 요소 선택/검사 (Select an element 버튼 사용)
- 요소 삭제/수정/추가 가능

##### Console 패널 활용  
- 자바스크립트 코드 실행
- 에러 메시지 확인
- console.log() 출력 확인
- 변수/객체 조회 가능

##### 개발자 도구 단축키
- Ctrl + Shift + C : 요소 선택 모드
- Ctrl + Shift + M : 모바일 뷰 토글
- Ctrl + Shift + P : 커맨드 메뉴
- Ctrl + L : 콘솔 내용 지우기


### 4-1. 제돌 스토리 사이트 index.html 파일 <body>의 배경색을 부트스트랩의 bg-warning 색 으로 수정해보기
- 방법 1
    - index.html 연다
    - 현재 <body> -> <body class="bg-warning"> 로 수정하여 저장한다.
    - 브라우저 새로고침 한다.
- 방법 2
    - 크롬 개발자 도구(F12)를 열고 Elements 탭을 선택합니다.
    - body 태그를 찾아 background-color 속성을 확인합니다.
    - main.css 파일에서 body 스타일에서 background-color 의 색코드를  bg-warning 해당하는 색코드(#ffc107)로 수정합니다.    

### 4-2. 채팅창의 전송 버튼색을 초록색(bg-success)으로 수정해보기

### 4-3.  main.js 파일에서 채팅 횟수를 3회로 제한해보기

- 1. main.js 파일을 열어서 전역 변수로 채팅 횟수를 저장할 변수를 추가합니다.
    ```javascript
    let chatCount = 0; // 채팅 횟수를 저장할 변수
    ```

- 2. sendMessage 함수에서 메시지를 보내기 전에 채팅 횟수를 체크하는 코드를 추가합니다.
    ```javascript
    if (chatCount >= 3) {
        $("#error-message")
            .text("채팅 횟수가 3회를 초과했습니다.")
            .removeClass("d-none");
        return;
    }
    chatCount++; // 메시지 전송 시 카운트 증가
    ```

- 3. 브라우저를 새로고침하여 테스트합니다.
    - 3회까지는 정상적으로 메시지가 전송됩니다.
    - 4회째부터는 에러 메시지가 표시되고 전송이 차단됩니다.

- 코드 설명
    - chatCount 변수: 현재까지의 채팅 횟수를 추적
    - if 조건문: 채팅 횟수가 3회 이상이면 에러 메시지 표시
    - removeClass("d-none"): 숨겨져 있던 에러 메시지를 보이게 함
    - return: 추가 실행을 중단하여 메시지 전송을 막음
- 코드 문제점
    - 브라우저를 새로고침하면 JavaScript 변수들이 초기화되어 채팅 횟수 제한이 풀림
    - 이유: chatCount는 일반 변수이므로 페이지 새로고침 시 초기값(0)으로 돌아감

### 4-4. 채팅 횟수가 초기화 되지 않도록 main.js 파일을 수정하기    
- localStorage를 사용하여 브라우저에 채팅 횟수를 저장
    ```javascript
    // 채팅 횟수를 localStorage에서 가져오거나 없으면 0으로 초기화
    let chatCount = parseInt(localStorage.getItem('chatCount')) || 0;
    
    // 메시지 전송 시 localStorage에 횟수 저장
    chatCount++;
    localStorage.setItem('chatCount', chatCount);
    ```
- F12 개발자 도구를 열어서 Application 탭의 Local Storage에서 chatCount 변수를 확인할 수 있음    
- 문제점    
    - 개발자 도구에서 Local Storage를 삭제하면 채팅 횟수가 초기화 됨

### 4-5. 문제점을 해결하기 위해서 서버에 채팅 횟수를 저장하여 관리하기
- 서버(main.py)에서 채팅 횟수를 관리하도록 수정
    1. main.py 파일에 채팅 횟수를 저장할 전역 변수와 사용자별 채팅 횟수를 저장할 딕셔너리 추가
    ```python
    # 사용자별 채팅 횟수를 저장할 딕셔너리
    chat_counts = {}
    MAX_CHATS = 3  # 최대 채팅 횟수 제한
    ```

    2. /chat 엔드포인트에서 채팅 횟수 체크 로직 추가
    ```python
    @app.post("/chat")
    async def chat(message: dict):
        try:
            # 사용자 IP 주소 가져오기
            client_host = request.client.host
            
            # 해당 사용자의 채팅 횟수 확인
            if client_host not in chat_counts:
                chat_counts[client_host] = 0
                
            # 채팅 횟수 제한 체크    
            if chat_counts[client_host] >= MAX_CHATS:
                return {"error": "채팅 횟수가 초과되었습니다."}
                
            # 채팅 횟수 증가
            chat_counts[client_host] += 1
            
            # 기존 채팅 처리 로직...
    ```

    3. main.js 파일에서 서버 응답 처리 부분 수정
    ```javascript
    $.ajax({
        // ... 기존 설정 ...
        success: function(response) {
            if (response.error) {
                $("#error-message")
                    .text(response.error)
                    .removeClass("d-none");
                return;
            }
            // 기존 성공 처리 로직...
        }
    });
    ```

- 장점
    - 브라우저나 로컬 스토리지를 초기화해도 채팅 제한이 유지됨
    - IP 주소 기반으로 사용자를 구분하여 더 정확한 제한 가능
    
- 단점
    - 서버를 재시작하면 채팅 횟수가 초기화됨
    - IP 주소가 변경되면 새로운 사용자로 인식됨

- 추가 개선 방안
    - 데이터베이스를 사용하여 채팅 횟수 영구 저장


### 4-7. 서버에 채팅 횟수를 초기화하는 엔드포인트 추가하기
- main.py 파일에 초기화 엔드포인트 추가
    ```python
    @app.post("/reset-chat-count")
    async def reset_chat_count():
        chat_counts.clear()
        return {"message": "채팅 횟수가 초기화되었습니다."}
    ```

## 5. 과제

### 과제1: 채팅 횟수를 초기화하는 엔드포인트를 실행할 버튼을 웹페이지에 추가하고 테스트 해보기




### 과제2: 초기화 엔드포인트가 특정한 IP 접속한 경우만 실행되게 추가해보기
